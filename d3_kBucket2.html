//<script>
/*
index.js - "discover": Node discovery based on Kademlia DHT protocol
The MIT License (MIT)
Copyright (c) 2013-2014 Tristan Slominski
Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:
The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/


var clone = (function() {

function _instanceof(obj, type) {
  return type != null && obj instanceof type;
}

var nativeMap;
try {
  nativeMap = Map;
} catch(_) {
  // maybe a reference error because no `Map`. Give it a dummy value that no
  // value will ever be an instanceof.
  nativeMap = function() {};
}

var nativeSet;
try {
  nativeSet = Set;
} catch(_) {
  nativeSet = function() {};
}

var nativePromise;
try {
  nativePromise = Promise;
} catch(_) {
  nativePromise = function() {};
}

/**
 * Clones (copies) an Object using deep copying.
 *
 * This function supports circular references by default, but if you are certain
 * there are no circular references in your object, you can save some CPU time
 * by calling clone(obj, false).
 *
 * Caution: if `circular` is false and `parent` contains circular references,
 * your program may enter an infinite loop and crash.
 *
 * @param `parent` - the object to be cloned
 * @param `circular` - set to true if the object to be cloned may contain
 *    circular references. (optional - true by default)
 * @param `depth` - set to a number if the object is only to be cloned to
 *    a particular depth. (optional - defaults to Infinity)
 * @param `prototype` - sets the prototype to be used when cloning an object.
 *    (optional - defaults to parent prototype).
 * @param `includeNonEnumerable` - set to true if the non-enumerable properties
 *    should be cloned as well. Non-enumerable properties on the prototype
 *    chain will be ignored. (optional - false by default)
*/
function clone(parent, circular, depth, prototype, includeNonEnumerable) {
  if (typeof circular === 'object') {
    depth = circular.depth;
    prototype = circular.prototype;
    includeNonEnumerable = circular.includeNonEnumerable;
    circular = circular.circular;
  }
  // maintain two arrays for circular references, where corresponding parents
  // and children have the same index
  var allParents = [];
  var allChildren = [];

  var useBuffer = typeof Buffer != 'undefined';

  if (typeof circular == 'undefined')
    circular = true;

  if (typeof depth == 'undefined')
    depth = Infinity;

  // recurse this function so we don't reset allParents and allChildren
  function _clone(parent, depth) {
    // cloning null always returns null
    if (parent === null)
      return null;

    if (depth === 0)
      return parent;

    var child;
    var proto;
    if (typeof parent != 'object') {
      return parent;
    }

    if (_instanceof(parent, nativeMap)) {
      child = new nativeMap();
    } else if (_instanceof(parent, nativeSet)) {
      child = new nativeSet();
    } else if (_instanceof(parent, nativePromise)) {
      child = new nativePromise(function (resolve, reject) {
        parent.then(function(value) {
          resolve(_clone(value, depth - 1));
        }, function(err) {
          reject(_clone(err, depth - 1));
        });
      });
    } else if (clone.__isArray(parent)) {
      child = [];
    } else if (clone.__isRegExp(parent)) {
      child = new RegExp(parent.source, __getRegExpFlags(parent));
      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
    } else if (clone.__isDate(parent)) {
      child = new Date(parent.getTime());
    } else if (useBuffer && Buffer.isBuffer(parent)) {
      if (Buffer.from) {
        // Node.js >= 5.10.0
        child = Buffer.from(parent);
      } else {
        // Older Node.js versions
        child = new Buffer(parent.length);
        parent.copy(child);
      }
      return child;
    } else if (_instanceof(parent, Error)) {
      child = Object.create(parent);
    } else {
      if (typeof prototype == 'undefined') {
        proto = Object.getPrototypeOf(parent);
        child = Object.create(proto);
      }
      else {
        child = Object.create(prototype);
        proto = prototype;
      }
    }

    if (circular) {
      var index = allParents.indexOf(parent);

      if (index != -1) {
        return allChildren[index];
      }
      allParents.push(parent);
      allChildren.push(child);
    }

    if (_instanceof(parent, nativeMap)) {
      parent.forEach(function(value, key) {
        var keyChild = _clone(key, depth - 1);
        var valueChild = _clone(value, depth - 1);
        child.set(keyChild, valueChild);
      });
    }
    if (_instanceof(parent, nativeSet)) {
      parent.forEach(function(value) {
        var entryChild = _clone(value, depth - 1);
        child.add(entryChild);
      });
    }

    for (var i in parent) {
      var attrs = Object.getOwnPropertyDescriptor(parent, i);
      if (attrs) {
        child[i] = _clone(parent[i], depth - 1);
      }
    }

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(parent);
      for (var i = 0; i < symbols.length; i++) {
        // Don't need to worry about cloning a symbol because it is a primitive,
        // like a number or string.
        var symbol = symbols[i];
        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);
        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
          continue;
        }
        child[symbol] = _clone(parent[symbol], depth - 1);
        Object.defineProperty(child, symbol, descriptor);
      }
    }

    if (includeNonEnumerable) {
      var allPropertyNames = Object.getOwnPropertyNames(parent);
      for (var i = 0; i < allPropertyNames.length; i++) {
        var propertyName = allPropertyNames[i];
        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);
        if (descriptor && descriptor.enumerable) {
          continue;
        }
        child[propertyName] = _clone(parent[propertyName], depth - 1);
        Object.defineProperty(child, propertyName, descriptor);
      }
    }

    return child;
  }

  return _clone(parent, depth);
}

/**
 * Simple flat clone using prototype, accepts only objects, usefull for property
 * override on FLAT configuration object (no nested props).
 *
 * USE WITH CAUTION! This may not behave as you wish if you do not know how this
 * works.
 */
clone.clonePrototype = function clonePrototype(parent) {
  if (parent === null)
    return null;

  var c = function () {};
  c.prototype = parent;
  return new c();
};

// private utility functions

function __objToStr(o) {
  return Object.prototype.toString.call(o);
}
clone.__objToStr = __objToStr;

function __isDate(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Date]';
}
clone.__isDate = __isDate;

function __isArray(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Array]';
}
clone.__isArray = __isArray;

function __isRegExp(o) {
  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
}
clone.__isRegExp = __isRegExp;

function __getRegExpFlags(re) {
  var flags = '';
  if (re.global) flags += 'g';
  if (re.ignoreCase) flags += 'i';
  if (re.multiline) flags += 'm';
  return flags;
}
clone.__getRegExpFlags = __getRegExpFlags;

return clone;
})();


if (typeof reactor == "undefined" || !reactor) {
   (function () {

function Event(name){
  this.name = name;
  this.callbacks = [];
}
Event.prototype.registerCallback = function(callback){
  this.callbacks.push(callback);
};
 
function Reactor(){
  this.events = {};
}
 
Reactor.prototype.registerEvent = function(eventName){
  var event = new Event(eventName);
  this.events[eventName] = event;
};
 
Reactor.prototype.dispatchEvent = function(eventName, eventArgs){
  this.events[eventName].callbacks.forEach(function(callback){
    callback(eventArgs);
  });
};
 
Reactor.prototype.addEventListener = function(eventName, callback){
  this.events[eventName].registerCallback(callback);
};

window.reactor = new Reactor();

})();
}



reactor.registerEvent('added');
reactor.addEventListener('added', function(someObject){
  console.log('Added fired with data '+ someObject);
});

reactor.registerEvent('removed');
reactor.addEventListener('removed', function(someObject){
  console.log('Removed fired with data '+ someObject);
});

reactor.registerEvent('updated');
reactor.addEventListener('updated', function(someObject){
  console.log('Updated fired with data '+ someObject);
});


/*
//Sample Usage
//Creating and defining the event
reactor.registerEvent('big bang');
reactor.addEventListener('big bang', function(someObject){
  console.log('This is big bang listener yo!'+ someObject.a);
});

//Firing the event
reactor.dispatchEvent('big bang');
reactor.dispatchEvent('big bang',{a:1});
reactor.dispatchEvent('big bang',{a:55});

*/


//Checking if existing NodeID can be used
//This first block of if will initialize the configuration of KBucket
//Add Events, Messaging between different K-Buckets, and attach relevant distributed data


if (typeof KBucketOptions == "undefined" || !KBucketOptions) {

var KBucketOptions = {};
var sanitizedFLOAddress = new Uint8Array(20);  
KBucketOptions.localNodeId = window.crypto.getRandomValues(sanitizedFLOAddress);

}

if (typeof KBucket == "undefined" || !KBucket) {
  (function (options) {



var buf = new Uint8Array(20);
var randomBytes =  window.crypto.getRandomValues(buf);


/**
 * @param  {Uint8Array} array1
 * @param  {Uint8Array} array2
 * @return {Boolean}
 */
function arrayEquals (array1, array2) {
  if (array1 === array2) {
    return true
  }
  if (array1.length !== array2.length) {
    return false
  }
  for (let i = 0, length = array1.length; i < length; ++i) {
    if (array1[i] !== array2[i]) {
      return false
    }
  }
  return true
}

function createNode () {
  return { contacts: [], dontSplit: false, left: null, right: null }
}

function ensureInt8 (name, val) {
  if (!(val instanceof Uint8Array)) {
    throw new TypeError(name + ' is not a Uint8Array')
  }
}

/**
 * Implementation of a Kademlia DHT k-bucket used for storing
 * contact (peer node) information.
 *
 * @extends EventEmitter
 */
function KBucket(options = {})  {
  /**
   * `options`:
   *   `distance`: Function
   *     `function (firstId, secondId) { return distance }` An optional
   *     `distance` function that gets two `id` Uint8Arrays
   *     and return distance (as number) between them.
   *   `arbiter`: Function (Default: vectorClock arbiter)
   *     `function (incumbent, candidate) { return contact; }` An optional
   *     `arbiter` function that givent two `contact` objects with the same `id`
   *     returns the desired object to be used for updating the k-bucket. For
   *     more details, see [arbiter function](#arbiter-function).
   *   `localNodeId`: Uint8Array An optional Uint8Array representing the local node id.
   *     If not provided, a local node id will be created via `randomBytes(20)`.
   *     `metadata`: Object (Default: {}) Optional satellite data to include
   *     with the k-bucket. `metadata` property is guaranteed not be altered by,
   *     it is provided as an explicit container for users of k-bucket to store
   *     implementation-specific data.
   *   `numberOfNodesPerKBucket`: Integer (Default: 20) The number of nodes
   *     that a k-bucket can contain before being full or split.
   *     `numberOfNodesToPing`: Integer (Default: 3) The number of nodes to
   *     ping when a bucket that should not be split becomes full. KBucket will
   *     emit a `ping` event that contains `numberOfNodesToPing` nodes that have
   *     not been contacted the longest.
   *
   * @param {Object=} options optional
   */
  
    this.localNodeId = options.localNodeId || randomBytes
    this.numberOfNodesPerKBucket = options.numberOfNodesPerKBucket || 20
    this.numberOfNodesToPing = options.numberOfNodesToPing || 3
    this.distance = options.distance || KBucket.distance
    // use an arbiter from options or vectorClock arbiter by default
    this.arbiter = options.arbiter || KBucket.arbiter
    this.metadata = Object.assign({}, options.metadata)

    ensureInt8('option.localNodeId as parameter 1', this.localNodeId)

    this.root = createNode()
  

  /**
   * Default arbiter function for contacts with the same id. Uses
   * contact.vectorClock to select which contact to update the k-bucket with.
   * Contact with larger vectorClock field will be selected. If vectorClock is
   * the same, candidat will be selected.
   *
   * @param  {Object} incumbent Contact currently stored in the k-bucket.
   * @param  {Object} candidate Contact being added to the k-bucket.
   * @return {Object}           Contact to updated the k-bucket with.
   */
   this.arbiter =  function (incumbent, candidate) {
    return incumbent.vectorClock > candidate.vectorClock ? incumbent : candidate
  }

  /**
   * Default distance function. Finds the XOR
   * distance between firstId and secondId.
   *
   * @param  {Uint8Array} firstId  Uint8Array containing first id.
   * @param  {Uint8Array} secondId Uint8Array containing second id.
   * @return {Number}              Integer The XOR distance between firstId
   *                               and secondId.
   */
   this.distance = function (firstId, secondId) {
    let distance = 0
    let i = 0
    const min = Math.min(firstId.length, secondId.length)
    const max = Math.max(firstId.length, secondId.length)
    for (; i < min; ++i) {
      distance = distance * 256 + (firstId[i] ^ secondId[i])
    }
    for (; i < max; ++i) distance = distance * 256 + 255
    return distance
  }

  /**
   * Adds a contact to the k-bucket.
   *
   * @param {Object} contact the contact object to add
   */
  this.add = function (contact) {
    ensureInt8('contact.id', (contact || {}).id)

    let bitIndex = 0
    let node = this.root

    while (node.contacts === null) {
      // this is not a leaf node but an inner node with 'low' and 'high'
      // branches; we will check the appropriate bit of the identifier and
      // delegate to the appropriate node for further processing
      node = this._determineNode(node, contact.id, bitIndex++)
    }

    // check if the contact already exists
    const index = this._indexOf(node, contact.id)
    if (index >= 0) {
      this._update(node, index, contact)
      return this
    }

    if (node.contacts.length < this.numberOfNodesPerKBucket) {
      node.contacts.push(contact)
      reactor.dispatchEvent('added', contact)
      return this
    }

    // the bucket is full
    if (node.dontSplit) {
      // we are not allowed to split the bucket
      // we need to ping the first this.numberOfNodesToPing
      // in order to determine if they are alive
      // only if one of the pinged nodes does not respond, can the new contact
      // be added (this prevents DoS flodding with new invalid contacts)
      //this.emit('ping', node.contacts.slice(0, this.numberOfNodesToPing), contact)
      return this
    }

    this._split(node, bitIndex)
    return this.add(contact)
  }

  /**
   * Get the n closest contacts to the provided node id. "Closest" here means:
   * closest according to the XOR metric of the contact node id.
   *
   * @param  {Uint8Array} id  Contact node id
   * @param  {Number=} n      Integer (Default: Infinity) The maximum number of
   *                          closest contacts to return
   * @return {Array}          Array Maximum of n closest contacts to the node id
   */
  this.closest = function (id, n = Infinity) {
    ensureInt8('id', id)

    if ((!Number.isInteger(n) && n !== Infinity) || n <= 0) {
      throw new TypeError('n is not positive number')
    }

    let contacts = []

    for (let nodes = [ this.root ], bitIndex = 0; nodes.length > 0 && contacts.length < n;) {
      const node = nodes.pop()
      if (node.contacts === null) {
        const detNode = this._determineNode(node, id, bitIndex++)
        nodes.push(node.left === detNode ? node.right : node.left)
        nodes.push(detNode)
      } else {
        contacts = contacts.concat(node.contacts)
      }
    }

    return contacts
      .map(a => [this.distance(a.id, id), a])
      .sort((a, b) => a[0] - b[0])
      .slice(0, n)
      .map(a => a[1])
  }

  /**
   * Counts the total number of contacts in the tree.
   *
   * @return {Number} The number of contacts held in the tree
   */
  this.count = function () {
    // return this.toArray().length
    let count = 0
    for (const nodes = [ this.root ]; nodes.length > 0;) {
      const node = nodes.pop()
      if (node.contacts === null) nodes.push(node.right, node.left)
      else count += node.contacts.length
    }
    return count
  }

  /**
   * Determines whether the id at the bitIndex is 0 or 1.
   * Return left leaf if `id` at `bitIndex` is 0, right leaf otherwise
   *
   * @param  {Object} node     internal object that has 2 leafs: left and right
   * @param  {Uint8Array} id   Id to compare localNodeId with.
   * @param  {Number} bitIndex Integer (Default: 0) The bit index to which bit
   *                           to check in the id Uint8Array.
   * @return {Object}          left leaf if id at bitIndex is 0, right leaf otherwise.
   */
  this._determineNode = function (node, id, bitIndex) {
    // *NOTE* remember that id is a Uint8Array and has granularity of
    // bytes (8 bits), whereas the bitIndex is the bit index (not byte)

    // id's that are too short are put in low bucket (1 byte = 8 bits)
    // (bitIndex >> 3) finds how many bytes the bitIndex describes
    // bitIndex % 8 checks if we have extra bits beyond byte multiples
    // if number of bytes is <= no. of bytes described by bitIndex and there
    // are extra bits to consider, this means id has less bits than what
    // bitIndex describes, id therefore is too short, and will be put in low
    // bucket
    const bytesDescribedByBitIndex = bitIndex >> 3
    const bitIndexWithinByte = bitIndex % 8
    if ((id.length <= bytesDescribedByBitIndex) && (bitIndexWithinByte !== 0)) {
      return node.left
    }

    const byteUnderConsideration = id[bytesDescribedByBitIndex]

    // byteUnderConsideration is an integer from 0 to 255 represented by 8 bits
    // where 255 is 11111111 and 0 is 00000000
    // in order to find out whether the bit at bitIndexWithinByte is set
    // we construct (1 << (7 - bitIndexWithinByte)) which will consist
    // of all bits being 0, with only one bit set to 1
    // for example, if bitIndexWithinByte is 3, we will construct 00010000 by
    // (1 << (7 - 3)) -> (1 << 4) -> 16
    if (byteUnderConsideration & (1 << (7 - bitIndexWithinByte))) {
      return node.right
    }

    return node.left
  }

  /**
   * Get a contact by its exact ID.
   * If this is a leaf, loop through the bucket contents and return the correct
   * contact if we have it or null if not. If this is an inner node, determine
   * which branch of the tree to traverse and repeat.
   *
   * @param  {Uint8Array} id The ID of the contact to fetch.
   * @return {Object|Null}   The contact if available, otherwise null
   */
  this.get = function (id) {
    ensureInt8('id', id)

    let bitIndex = 0

    let node = this.root
    while (node.contacts === null) {
      node = this._determineNode(node, id, bitIndex++)
    }

    // index of uses contact id for matching
    const index = this._indexOf(node, id)
    return index >= 0 ? node.contacts[index] : null
  }

  /**
   * Returns the index of the contact with provided
   * id if it exists, returns -1 otherwise.
   *
   * @param  {Object} node    internal object that has 2 leafs: left and right
   * @param  {Uint8Array} id  Contact node id.
   * @return {Number}         Integer Index of contact with provided id if it
   *                          exists, -1 otherwise.
   */
  this._indexOf = function (node, id) {
    for (let i = 0; i < node.contacts.length; ++i) {
      if (arrayEquals(node.contacts[i].id, id)) return i
    }

    return -1
  }

  /**
   * Removes contact with the provided id.
   *
   * @param  {Uint8Array} id The ID of the contact to remove.
   * @return {Object}        The k-bucket itself.
   */
  this.remove = function (id) {
    ensureInt8('the id as parameter 1', id)

    let bitIndex = 0
    let node = this.root

    while (node.contacts === null) {
      node = this._determineNode(node, id, bitIndex++)
    }

    const index = this._indexOf(node, id)
    if (index >= 0) {
      const contact = node.contacts.splice(index, 1)[0]
      reactor.dispatchEvent('removed', contact)
    }

    return this
  }

  /**
   * Splits the node, redistributes contacts to the new nodes, and marks the
   * node that was split as an inner node of the binary tree of nodes by
   * setting this.root.contacts = null
   *
   * @param  {Object} node     node for splitting
   * @param  {Number} bitIndex the bitIndex to which byte to check in the
   *                           Uint8Array for navigating the binary tree
   */
  this._split = function (node, bitIndex) {
    node.left = createNode()
    node.right = createNode()

    // redistribute existing contacts amongst the two newly created nodes
    for (const contact of node.contacts) {
      this._determineNode(node, contact.id, bitIndex).contacts.push(contact)
    }

    node.contacts = null // mark as inner tree node

    // don't split the "far away" node
    // we check where the local node would end up and mark the other one as
    // "dontSplit" (i.e. "far away")
    const detNode = this._determineNode(node, this.localNodeId, bitIndex)
    const otherNode = node.left === detNode ? node.right : node.left
    otherNode.dontSplit = true
  }

  /**
   * Returns all the contacts contained in the tree as an array.
   * If this is a leaf, return a copy of the bucket. `slice` is used so that we
   * don't accidentally leak an internal reference out that might be
   * accidentally misused. If this is not a leaf, return the union of the low
   * and high branches (themselves also as arrays).
   *
   * @return {Array} All of the contacts in the tree, as an array
   */
  this.toArray = function () {
    let result = []
    for (const nodes = [ this.root ]; nodes.length > 0;) {
      const node = nodes.pop()
      if (node.contacts === null) nodes.push(node.right, node.left)
      else result = result.concat(node.contacts)
    }
    return result
  }

  /**
   * Updates the contact selected by the arbiter.
   * If the selection is our old contact and the candidate is some new contact
   * then the new contact is abandoned (not added).
   * If the selection is our old contact and the candidate is our old contact
   * then we are refreshing the contact and it is marked as most recently
   * contacted (by being moved to the right/end of the bucket array).
   * If the selection is our new contact, the old contact is removed and the new
   * contact is marked as most recently contacted.
   *
   * @param  {Object} node    internal object that has 2 leafs: left and right
   * @param  {Number} index   the index in the bucket where contact exists
   *                          (index has already been computed in a previous
   *                          calculation)
   * @param  {Object} contact The contact object to update.
   */
  this._update = function (node, index, contact) {
    // sanity check
    if (!arrayEquals(node.contacts[index].id, contact.id)) {
      throw new Error('wrong index for _update')
    }

    const incumbent = node.contacts[index]
    const selection = this.arbiter(incumbent, contact)
    // if the selection is our old contact and the candidate is some new
    // contact, then there is nothing to do
    if (selection === incumbent && incumbent !== contact) return

    node.contacts.splice(index, 1) // remove old contact
    node.contacts.push(selection) // add more recent contact version
    reactor.dispatchEvent('updated', incumbent.concat(selection))
  }
}

window.KBucket = new KBucket(options)

})(KBucketOptions);

}







/* Now LRU Cache */


var LruCache = (function(){

var module ={}; 
var exports = module.exports = {};

// A linked list to keep track of recently-used-ness
const Yallist = function() {

'use strict'
module.exports = Yallist

Yallist.Node = Node
Yallist.create = Yallist

function Yallist (list) {
  var self = this
  if (!(self instanceof Yallist)) {
    self = new Yallist()
  }

  self.tail = null
  self.head = null
  self.length = 0

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item)
    })
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i])
    }
  }

  return self
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list')
  }

  var next = node.next
  var prev = node.prev

  if (next) {
    next.prev = prev
  }

  if (prev) {
    prev.next = next
  }

  if (node === this.head) {
    this.head = next
  }
  if (node === this.tail) {
    this.tail = prev
  }

  node.list.length--
  node.next = null
  node.prev = null
  node.list = null
}

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var head = this.head
  node.list = this
  node.next = head
  if (head) {
    head.prev = node
  }

  this.head = node
  if (!this.tail) {
    this.tail = node
  }
  this.length++
}

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var tail = this.tail
  node.list = this
  node.prev = tail
  if (tail) {
    tail.next = node
  }

  this.tail = node
  if (!this.head) {
    this.head = node
  }
  this.length++
}

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined
  }

  var res = this.tail.value
  this.tail = this.tail.prev
  if (this.tail) {
    this.tail.next = null
  } else {
    this.head = null
  }
  this.length--
  return res
}

Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined
  }

  var res = this.head.value
  this.head = this.head.next
  if (this.head) {
    this.head.prev = null
  } else {
    this.tail = null
  }
  this.length--
  return res
}

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.next
  }
}

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.prev
  }
}

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.next
  }
  return res
}

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.prev
  }
  return res
}

Yallist.prototype.reduce = function (fn, initial) {
  var acc
  var walker = this.head
  if (arguments.length > 1) {
    acc = initial
  } else if (this.head) {
    walker = this.head.next
    acc = this.head.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i)
    walker = walker.next
  }

  return acc
}

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc
  var walker = this.tail
  if (arguments.length > 1) {
    acc = initial
  } else if (this.tail) {
    walker = this.tail.prev
    acc = this.tail.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i)
    walker = walker.prev
  }

  return acc
}

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.next
  }
  return arr
}

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.prev
  }
  return arr
}

Yallist.prototype.slice = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.reverse = function () {
  var head = this.head
  var tail = this.tail
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev
    walker.prev = walker.next
    walker.next = p
  }
  this.head = tail
  this.tail = head
  return this
}

function push (self, item) {
  self.tail = new Node(item, self.tail, null, self)
  if (!self.head) {
    self.head = self.tail
  }
  self.length++
}

function unshift (self, item) {
  self.head = new Node(item, null, self.head, self)
  if (!self.tail) {
    self.tail = self.head
  }
  self.length++
}

function Node (value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list)
  }

  this.list = list
  this.value = value

  if (prev) {
    prev.next = this
    this.prev = prev
  } else {
    this.prev = null
  }

  if (next) {
    next.prev = this
    this.next = next
  } else {
    this.next = null
  }
}

try {
  // add if support for Symbol.iterator is present

(function (Yallist) {
  Yallist.prototype[Symbol.iterator] = function* () {
    for (let walker = this.head; walker; walker = walker.next) {
      yield walker.value
    }
  }
})(Yallist);

/*  require('./iterator.js')(Yallist)
*/} catch (er) {}

}

const MAX = Symbol('max')
const LENGTH = Symbol('length')
const LENGTH_CALCULATOR = Symbol('lengthCalculator')
const ALLOW_STALE = Symbol('allowStale')
const MAX_AGE = Symbol('maxAge')
const DISPOSE = Symbol('dispose')
const NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet')
const LRU_LIST = Symbol('lruList')
const CACHE = Symbol('cache')
const UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet')

const naiveLength = () => 1

// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
class LRUCache {
  constructor (options) {
    if (typeof options === 'number')
      options = { max: options }

    if (!options)
      options = {}

    if (options.max && (typeof options.max !== 'number' || options.max < 0))
      throw new TypeError('max must be a non-negative number')
    // Kind of weird to have a default max of Infinity, but oh well.
    const max = this[MAX] = options.max || Infinity

    const lc = options.length || naiveLength
    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc
    this[ALLOW_STALE] = options.stale || false
    if (options.maxAge && typeof options.maxAge !== 'number')
      throw new TypeError('maxAge must be a number')
    this[MAX_AGE] = options.maxAge || 0
    this[DISPOSE] = options.dispose
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false
    this.reset()
  }

  // resize the cache when the max changes.
  set max (mL) {
    if (typeof mL !== 'number' || mL < 0)
      throw new TypeError('max must be a non-negative number')

    this[MAX] = mL || Infinity
    trim(this)
  }
  get max () {
    return this[MAX]
  }

  set allowStale (allowStale) {
    this[ALLOW_STALE] = !!allowStale
  }
  get allowStale () {
    return this[ALLOW_STALE]
  }

  set maxAge (mA) {
    if (typeof mA !== 'number')
      throw new TypeError('maxAge must be a non-negative number')

    this[MAX_AGE] = mA
    trim(this)
  }
  get maxAge () {
    return this[MAX_AGE]
  }

  // resize the cache when the lengthCalculator changes.
  set lengthCalculator (lC) {
    if (typeof lC !== 'function')
      lC = naiveLength

    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC
      this[LENGTH] = 0
      this[LRU_LIST].forEach(hit => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)
        this[LENGTH] += hit.length
      })
    }
    trim(this)
  }
  get lengthCalculator () { return this[LENGTH_CALCULATOR] }

  get length () { return this[LENGTH] }
  get itemCount () { return this[LRU_LIST].length }

  rforEach (fn, thisp) {
    thisp = thisp || this
    for (let walker = this[LRU_LIST].tail; walker !== null;) {
      const prev = walker.prev
      forEachStep(this, fn, walker, thisp)
      walker = prev
    }
  }

  forEach (fn, thisp) {
    thisp = thisp || this
    for (let walker = this[LRU_LIST].head; walker !== null;) {
      const next = walker.next
      forEachStep(this, fn, walker, thisp)
      walker = next
    }
  }

  keys () {
    return this[LRU_LIST].toArray().map(k => k.key)
  }

  values () {
    return this[LRU_LIST].toArray().map(k => k.value)
  }

  reset () {
    if (this[DISPOSE] &&
        this[LRU_LIST] &&
        this[LRU_LIST].length) {
      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value))
    }

    this[CACHE] = new Map() // hash of items by key
    this[LRU_LIST] = new Yallist() // list of items in order of use recency
    this[LENGTH] = 0 // length of items in the list
  }

  dump () {
    return this[LRU_LIST].map(hit =>
      isStale(this, hit) ? false : {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }).toArray().filter(h => h)
  }

  dumpLru () {
    return this[LRU_LIST]
  }

  set (key, value, maxAge) {
    maxAge = maxAge || this[MAX_AGE]

    if (maxAge && typeof maxAge !== 'number')
      throw new TypeError('maxAge must be a number')

    const now = maxAge ? Date.now() : 0
    const len = this[LENGTH_CALCULATOR](value, key)

    if (this[CACHE].has(key)) {
      if (len > this[MAX]) {
        del(this, this[CACHE].get(key))
        return false
      }

      const node = this[CACHE].get(key)
      const item = node.value

      // dispose of the old one before overwriting
      // split out into 2 ifs for better coverage tracking
      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET])
          this[DISPOSE](key, item.value)
      }

      item.now = now
      item.maxAge = maxAge
      item.value = value
      this[LENGTH] += len - item.length
      item.length = len
      this.get(key)
      trim(this)
      return true
    }

    const hit = new Entry(key, value, len, now, maxAge)

    // oversized objects fall out of cache automatically.
    if (hit.length > this[MAX]) {
      if (this[DISPOSE])
        this[DISPOSE](key, value)

      return false
    }

    this[LENGTH] += hit.length
    this[LRU_LIST].unshift(hit)
    this[CACHE].set(key, this[LRU_LIST].head)
    trim(this)
    return true
  }

  has (key) {
    if (!this[CACHE].has(key)) return false
    const hit = this[CACHE].get(key).value
    return !isStale(this, hit)
  }

  get (key) {
    return get(this, key, true)
  }

  peek (key) {
    return get(this, key, false)
  }

  pop () {
    const node = this[LRU_LIST].tail
    if (!node)
      return null

    del(this, node)
    return node.value
  }

  del (key) {
    del(this, this[CACHE].get(key))
  }

  load (arr) {
    // reset the cache
    this.reset()

    const now = Date.now()
    // A previous serialized cache has the most recent items first
    for (let l = arr.length - 1; l >= 0; l--) {
      const hit = arr[l]
      const expiresAt = hit.e || 0
      if (expiresAt === 0)
        // the item was created without expiration in a non aged cache
        this.set(hit.k, hit.v)
      else {
        const maxAge = expiresAt - now
        // dont add already expired items
        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge)
        }
      }
    }
  }

  prune () {
    this[CACHE].forEach((value, key) => get(this, key, false))
  }
}

const get = (self, key, doUse) => {
  const node = self[CACHE].get(key)
  if (node) {
    const hit = node.value
    if (isStale(self, hit)) {
      del(self, node)
      if (!self[ALLOW_STALE])
        return undefined
    } else {
      if (doUse) {
        if (self[UPDATE_AGE_ON_GET])
          node.value.now = Date.now()
        self[LRU_LIST].unshiftNode(node)
      }
    }
    return hit.value
  }
}

const isStale = (self, hit) => {
  if (!hit || (!hit.maxAge && !self[MAX_AGE]))
    return false

  const diff = Date.now() - hit.now
  return hit.maxAge ? diff > hit.maxAge
    : self[MAX_AGE] && (diff > self[MAX_AGE])
}

const trim = self => {
  if (self[LENGTH] > self[MAX]) {
    for (let walker = self[LRU_LIST].tail;
      self[LENGTH] > self[MAX] && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      const prev = walker.prev
      del(self, walker)
      walker = prev
    }
  }
}

const del = (self, node) => {
  if (node) {
    const hit = node.value
    if (self[DISPOSE])
      self[DISPOSE](hit.key, hit.value)

    self[LENGTH] -= hit.length
    self[CACHE].delete(hit.key)
    self[LRU_LIST].removeNode(node)
  }
}

class Entry {
  constructor (key, value, length, now, maxAge) {
    this.key = key
    this.value = value
    this.length = length
    this.now = now
    this.maxAge = maxAge || 0
  }
}

const forEachStep = (self, fn, node, thisp) => {
  let hit = node.value
  if (isStale(self, hit)) {
    del(self, node)
    if (!self[ALLOW_STALE])
      hit = undefined
  }
  if (hit)
    fn.call(thisp, hit.value, hit.key, self)
}

module.exports = LRUCache
return module.exports;
})(); 


//Now utils.inspect

var util = {};
util.trace = function(...parameter){
    } 



 
/*clone = require('clone')*/

/*crypto.randomBytes(20).toString('base64');
*/

/*crypto = require('crypto')
events = require('events'),

*/
/*var KBucket = require('k-bucket'),*/
    /*LruCache = require('lru-cache'),*/
    /*util = require('util');*/

/*
  * `options`:
    * `CONCURRENCY_CONSTANT`: _Integer_ _(Default: 3)_ Number of concurrent
            FIND-NODE requests to the network per `find` request.
    * `arbiter`: _Function_ _(Default: vector clock arbiter)_
            `function (incumbent, candidate) {}` An optional arbiter function.
            `arbiter` function is used in three places. First, it is used as the
            k-bucket `arbiter` function. Second, it is used to determine whether
            a new remote contact should be inserted into the LRU cache (if
            `arbiter` returns something `!==` to the cached contact the remote
            contact will be inserted). Third, it is used to determine if
            unregistering a contact will succeed (if `arbiter` returns contact
            `===` to the stored contact, unregister will fail).
    * `arbiterDefaults`: _Function_ _(Default: vector clock arbiter defaults)_
            `function (contact) {}` An optional arbiter defaults function that
            sets `contact` arbiter defaults when a `contact` is first registered.
            Remote contacts that are added via `add` are assumed to have
            appropriate arbiter properties already set.
    * `eventTrace`: _Boolean_ _(Default: false)_ If set to `true`, Discover will
            emit `~trace` events for debugging purposes.
    * `inlineTrace`: _Boolean_ _(Default: false)_ If set to `true`, Discover
            will log to console `~trace` messages for debugging purposes.
    * `maxCacheSize`: _Number_ _(Default: 1000)_ Maximum number of `contacts` to
            keep in non-kBucket cache (see #6)
    * `noCache`: _Boolean_ _(Default: false)_ If `true`, non-kBucket cache is not
            used.
    * `seeds`: _Array_ _(Default: [])_ An array of seed `contact` Objects that
            the `transport` understands.
    * `transport`: _Object_ _(Default: `discover-tcp-transport`)_ An optional
            initialized and ready to use transport module for sending
            communications that conforms to the Transport Protocol.
            If `transport` is not provided, a new instance of
            `discover-tcp-transport` will be created and used with default
            settings.
*/

function test(){ var Discover = module.exports = function Discover (options) {
    var self = this;
    //events.EventEmitter.call(self);

    options = options || {};

    self.CONCURRENCY_CONSTANT = options.CONCURRENCY_CONSTANT || 3;
    self.maxCacheSize = options.maxCacheSize || 1000;
    self.noCache = options.noCache === undefined ? false : options.noCache;

    self.arbiterDefaults = options.arbiterDefaults || function arbiterDefaults(contact) {
        if (!contact.vectorClock) {
            contact.vectorClock = 0;
        }
        return contact;
    };

    self.arbiter = options.arbiter || function arbiter(incumbent, candidate) {
        if (!incumbent
            || (incumbent && !incumbent.vectorClock)
            || (incumbent && incumbent.vectorClock && candidate.vectorClock
                && (candidate.vectorClock >= incumbent.vectorClock))) {

            return candidate;
        }
        return incumbent;
    };

    self.seeds = options.seeds || [];
    // configure tracing for debugging purposes
    // TODO: probably change this to some sort of sane logging
    self.options = options;

    self.tracing = (options.inlineTrace || options.eventTrace);

    if (self.tracing)
        self.trace('tracing is enabled');

    self.transport = options.transport;
    if (!self.transport) {
        var TcpTransport = require('discover-tcp-transport');
        self.transport = new TcpTransport(options);
    }

    // register a listener to update our k-buckets with nodes that we manage
    // contact with
    self.transport.on('node', function (error, contact, nodeId, response) {
        var latency = self.timerEndInMilliseconds('find.request.ms', contact.id + nodeId);
        if (error) {
            self.emit('stats.timers.find.request.ms', latency);
            return; // failed contact
        }

        if (Array.isArray(response)) {
            // arbiter "closer" responses against locally registered contacts
            response.forEach(function (res) {
                if (self.kBuckets[res.id]) {
                    self.kBuckets[res.id].contact =
                        self.arbiter(self.kBuckets[res.id].contact, res);
                }
            });
        } else if (response && response.id) {
            // arbiter exact match response against locally registered contacts
            if (self.kBuckets[response.id]) {
                self.kBuckets[response.id].contact =
                    self.arbiter(self.kBuckets[response.id].contact, response);
            }
        }

        // we successfully contacted the "contact", add it
        self.add(contact);
        self.emit('stats.timers.find.request.ms', latency);
    });

    // register a listener to handle transport 'findNode' events
    self.transport.on('findNode', function (nodeId, sender, callback) {
        if (self.tracing)
            self.trace("on 'findNode' - nodeId: " + nodeId + ", sender: " + util.inspect(sender));
        // check if nodeId is one of the locally registered nodes
        var localContactKBucket = self.kBuckets[nodeId];
        if (localContactKBucket) {
            callback(null, localContactKBucket.contact);
        }

        var closestKBuckets = self.getClosestKBuckets(nodeId);
        var closestContacts = self.getClosestContacts(nodeId, closestKBuckets);

        // add the sender if it exists
        if (sender) {
            // we do it only after we already got the closest contact to prevent
            // always responding with exact match to the sender if the sender is
            // announcing (searching for itself)

            // first, check if sender contact id is locally registered
            if (self.kBuckets[sender.id]) {
                // sender is the same as locally registered contact
                // need to arbiter which contact version should be retained
                self.kBuckets[sender.id].contact =
                    self.arbiter(self.kBuckets[sender.id].contact, sender);
            } else {
                var senderClosestKBuckets = self.getClosestKBuckets(sender.id);
                if (senderClosestKBuckets.length == 0) {
                    if (self.tracing)
                        self.trace('no kBuckets for findNode sender '
                            + util.inspect(sender));
                } else {
                    var senderClosestKBucketId = senderClosestKBuckets[0].id;
                    var senderClosestKBucket =
                        self.kBuckets[senderClosestKBucketId].kBucket;
                    if (!senderClosestKBucket) {
                        if (self.tracing)
                            self.trace('no closest kBucket for findNode sender '
                                + util.inspect(sender));
                    } else {
                        var clonedSender = clone(sender);
                        if (self.tracing)
                            self.trace('adding ' + util.inspect(clonedSender)
                                + ' to kBucket ' + senderClosestKBucketId);
                        clonedSender.id = new Buffer(clonedSender.id, "base64");
                        senderClosestKBucket.add(clonedSender);
                    }
                }
            }
        }

        // check if we already responded prior to processing the sender
        if (localContactKBucket)
            return;

        if (closestContacts.length == 0) {
            return callback(null, []);
        }

        // check for exact match
        if (closestContacts[0].id.toString("base64") == nodeId) {
            var contact = clone(closestContacts[0]);
            contact.id = contact.id.toString("base64");
            return callback(null, contact);
        }

        // return closest contacts
        var contacts = [];
        closestContacts.forEach(function (closeContact) {
            var contact = clone(closeContact);
            contact.id = contact.id.toString("base64");
            // hide implementation details
            delete contact.distance;
            contacts.push(contact);
        });

        return callback(null, contacts);
    });

    // register a listener to handle transport 'ping' events
    self.transport.on('ping', function (nodeId, sender, callback) {
        if (self.tracing)
            self.trace("on 'ping' - nodeId: " + nodeId + ", sender: " + util.inspect(sender));

        // add the sender
        // in contrast to self.transport.on('findNode', ...) we can add the
        // sender prior to responding because it is verifying a ping for a
        // specific node and not searching for one, the 'findNode' consideration
        // to update K-Buckets only after responding does not apply in this case
        var senderClosestKBuckets = self.getClosestKBuckets(sender.id);
        if (senderClosestKBuckets.length == 0) {
            if (self.tracing)
                self.trace('no kBuckets for ping sender ' + util.inspect(sender));
        } else {
            var senderClosestKBucketId = senderClosestKBuckets[0].id;
            var senderClosestKBucket = self.kBuckets[senderClosestKBucketId].kBucket;
            if (!senderClosestKBucket) {
                if (self.tracing)
                    self.trace('no closest kBucket for ping sender ' + util.inspect(sender));
            } else {
                var clonedSender = clone(sender);
                if (self.tracing)
                    self.trace('adding ' + util.inspect(clonedSender) + ' to kBucket ' + senderClosestKBucketId);
                clonedSender.id = new Buffer(clonedSender.id, "base64");
                senderClosestKBucket.add(clonedSender);
            }
        }

        // check if nodeId is one of the locally registered nodes
        var localContactKBucket = self.kBuckets[nodeId];
        if (localContactKBucket) {
            callback(null, localContactKBucket.contact);
        } else {
            // the nodeId is not one of the locally registered nodes, ping fail
            callback(true);
        }
    });

    // register a listener to handle transport 'reached' events
    self.transport.on('reached', function (contact) {
        if (self.tracing)
            self.trace('reached ' + util.inspect(contact));

        // we successfully reached a contact, add it (refreshes the contact)
        self.add(contact);
    });

    // register a listener to handle transport 'unreachable' events
    self.transport.on('unreachable', function (contact) {
        self.unreachable(contact);
    });

    self.kBuckets = {};
    if (self.noCache) {
        self.lruCache = {
            del: function () {},
            get: function () {},
            set: function () {},
        };
    } else {
        self.lruCache = LruCache(self.maxCacheSize);
    }
    self.timers = {
        'find.ms': {},
        'find.request.ms': {},
        'find.round.ms': {}
    };
};

//util.inherits(Discover, events.EventEmitter);
//REMOVE EVENT EMITTER

/*
  * `remoteContact`: _Object_ Contact object to add that is not managed by this
      Discover node.
    * `id`: _String (base64)_ The contact id, base64 encoded.
    * `data`: _Any_ Data to be included with the contact, it is guaranteed to be
        returned for anyone querying for this `contact` by `id`.
  * Return: _Object_ Contact that was added.
*/
Discover.prototype.add = function add (remoteContact) {
    var self = this;

    if (!remoteContact.id || typeof remoteContact.id !== 'string') {
        throw new Error("Invalid or missing contact.id");
    }

    // even if we don't have kBuckets to update, we can still store information
    // in LRU cache (check using arbiter to update cache with latest only)
    var cached = self.lruCache.get(remoteContact.id);
    var selection = self.arbiter(cached, remoteContact);
    if (selection !== cached) {
        self.lruCache.set(remoteContact.id, remoteContact);
    }

    if (Object.keys(self.kBuckets).length == 0) {
        return null; // no k-buckets to update
    }

    // first, check if remote contact id is locally registered
    if (self.kBuckets[remoteContact.id]) {
        // remote contact id is same as locally registered contact id
        // need to arbiter which contact version should be retained
        // (we already calculated the selection)
        self.kBuckets[remoteContact.id].contact = selection;
    } else {
        // we pick the closest kBucket to the node id of our contact to store the
        // data in, since they have the most space to accomodate near-by node ids
        // (inherent KBucket property)
        var closestKBuckets = self.getClosestKBuckets(remoteContact.id);
        var closestKBucketId = closestKBuckets[0].id;
        var closestKBucket = self.kBuckets[closestKBucketId].kBucket;
        var clonedContact = clone(remoteContact);
        if (self.tracing) {
            self.trace('adding ' + util.inspect(clonedContact) + ' to kBucket '
                + closestKBucketId);
        }
        // convert id from string to Buffer
        clonedContact.id = new Buffer(clonedContact.id, "base64");
        closestKBucket.add(clonedContact);
    }

    return remoteContact;
};

/*
  * `query`: _Object_ Object containing query state for this request.
    * `nodeId`: _String (base64)_ Base64 encoded node id to find.
    * `nodes`: _Array_ `contact`s to query for `nodeId` arranged from closest to
            farthest.
      * `node`:
        * `id`: _String (base64)_ Base64 encoded contact id.
    * `nodesMap`: _Object_ A map to the same `contact`s already present in
            `nodes` for O(1) access.
  * `callback`: _Function_ The callback to call with result.
*/
Discover.prototype.executeQuery = function executeQuery (query, callback) {
    var self = this;
    self.timerStart('find.round.ms', query.nodeId);

    if (self.tracing)
        self.trace('executeQuery(' + util.inspect(query, false, null) + ')');

    // query already successfully completed
    if (query.done)
        return;

    // if we have no nodes, we can't query anything
    if (!query.nodes || query.nodes.length == 0) {
        var latency = self.timerEndInMilliseconds('find.ms', query.nodeId);
        var roundLatency = self.timerEndInMilliseconds('find.round.ms', query.nodeId);
        callback(new Error("No known nodes to query"));
        self.emit('stats.timers.find.ms', latency);
        self.emit('stats.timers.find.round.ms', roundLatency);
        return;
    }

    if (query.index === undefined)
        query.index = 0;
    if (query.closest === undefined)
        query.closest = query.nodes[0];
    if (query.ongoingRequests === undefined)
        query.ongoingRequests = 0;
    if (query.newNodes === undefined)
        query.newNodes = [];

    // we listen for `node` events that contain the nodeId we asked for
    // this helps to decouple discover from the transport and allows us to
    // benefit from other ongoing queries (TODO: "prove" this)
    //
    // because executeQuery can be called multiple times on the same query,
    // we keep the state
    if (!query.listener) {
        // TODO: maybe there is an opportunity here to generate events
        // uniquely named by "nodeId" so I don't have to have tons of listeners
        // listen to everything and throw away what they don't want?
        query.listener = function (error, contact, nodeId, response) {
            // filter other queries
            if (nodeId != query.nodeId)
                return;

            // query already successfully completed
            if (query.done)
                return;

            // request has been handled
            // TODO: what happens if two requests for the same nodeId are
            //       happening at the same time?
            // maybe do a check prior to executeQuery to not duplicate searches
            // for the same nodeId across the network?
            query.ongoingRequests--;

            if (error) {
                if (self.tracing) {
                    self.trace('error response from ' + util.inspect(contact) +
                        ' looking for ' + nodeId + ': ' + util.inspect(error));
                }
                var contactRecord = query.nodesMap[contact.id];

                if (!contactRecord)
                    return;

                if (contactRecord.kBucket) {
                    // we have a kBucket to report unreachability to
                    // remove from kBucket
                    var kBucketInfo = self.kBuckets[contactRecord.kBucket.id];
                    if (!kBucketInfo) {
                        return;
                    }

                    var kBucket = kBucketInfo.kBucket;
                    if (!kBucket) {
                        return;
                    }

                    var contactRecordToRemove = clone(contactRecord);
                    contactRecordToRemove.id =
                        new Buffer(contactRecord.id, 'base64');
                    kBucket.remove(contactRecordToRemove);
                }

                contactRecord.contacted = true;

                // console.dir(query);

                // initiate next request if there are still queries to be made
                if (query.index < query.nodes.length
                    && query.ongoingRequests < self.CONCURRENCY_CONSTANT) {
                    process.nextTick(function () {
                        self.executeQuery(query, callback);
                    });
                } else {
                    self.queryCompletionCheck(query, callback);
                }
                return; // handled error
            }

            // we have a response, it could be an Object or Array

            if (self.tracing) {
                self.trace('response from ' + util.inspect(contact) +
                    ' looking for ' + nodeId + ': ' + util.inspect(response));
            }
            if (Array.isArray(response)) {
                // add the closest contacts to new nodes
                query.newNodes = query.newNodes.concat(response);

                // TODO: same code inside error handler
                // initiate next request if there are still queries to be made
                if (query.index < query.nodes.length
                    && query.ongoingRequests < self.CONCURRENCY_CONSTANT) {
                    process.nextTick(function () {
                        self.executeQuery(query, callback);
                    });
                } else {
                    self.queryCompletionCheck(query, callback);
                }
                return;
            }

            // we have a response Object, found the contact!
            // add the new contact to the closestKBucket
            var finalClosestKBuckets = self.getClosestKBuckets(response.id);
            if (finalClosestKBuckets.length > 0) {
                var finalClosestKBucket =
                    self.kBuckets[finalClosestKBuckets[0].id].kBucket;
                var contact = clone(response);
                contact.id = new Buffer(contact.id, "base64");
                finalClosestKBucket.add(contact);
            }

            // return the response and stop querying
            var latency = self.timerEndInMilliseconds('find.ms', nodeId);
            var roundLatency = self.timerEndInMilliseconds('find.round.ms', nodeId);
            callback(null, response);
            query.done = true;
            self.transport.removeListener('node', query.listener);
            self.emit('stats.timers.find.ms', latency);
            self.emit('stats.timers.find.round.ms', roundLatency);
            return;
        };
        self.transport.on('node', query.listener);
    }

    for (query.index = query.index || 0;
        query.index < query.nodes.length
            && query.ongoingRequests < self.CONCURRENCY_CONSTANT;
        query.index++) {

        query.ongoingRequests++;
        self.timerStart('find.request.ms', query.nodes[query.index].id + query.nodeId);
        self.transport.findNode(query.nodes[query.index], query.nodeId, query.sender);
    }

    // console.log("INSIDE EXECUTE QUERY");
    // console.dir(query);
    self.queryCompletionCheck(query, callback);
};

/*
  * `nodeId`: _String (base64)_ The node id to find, base64 encoded.
  * `callback`: _Function_ The callback to call with the result of searching for
          `nodeId`.
  * `announce`: _Object_ _(Default: undefined)_ _**CAUTION: reserved for
          internal use**_ Contact object, if specified, it indicates an
          announcement to the network so we ask the network instead of
          satisfying request locally and the sender is the `announce` contact
          object.
*/
Discover.prototype.find = function find (nodeId, callback, announce) {
    var self = this;
    self.timerStart('find.ms', nodeId);

    var traceHeader;

    if (self.tracing) {
        traceHeader = "find(" + nodeId + "): ";
    }

    // see if we have a local match, and return it if not announcing
    if (!announce && self.kBuckets[nodeId]) {
        var latency = self.timerEndInMilliseconds('find.ms', nodeId);
        callback(null, self.kBuckets[nodeId].contact);
        self.emit('stats.timers.find.ms', latency);
        return;
    }

    // see if we have a cache match, and return it if not announcing
    var cached = self.lruCache.get(nodeId);
    if (!announce && cached) {
        var latency = self.timerEndInMilliseconds('find.ms', nodeId);
        callback(null, cached);
        self.emit('stats.timers.find.ms', latency);
        return;
    }

    // if we have no kBuckets, that means we haven't registered any nodes yet
    // the only nodes we are aware of are the seed nodes
    if (Object.keys(self.kBuckets).length == 0) {
        if (self.tracing)
            self.trace(traceHeader + 'no kBuckets, delegating to findViaSeeds()');
        return self.findViaSeeds(nodeId, callback, announce);
    }

    var closestKBuckets = self.getClosestKBuckets(nodeId);

    if (self.tracing) {
        self.trace(traceHeader + 'have ' + closestKBuckets.length + ' kBuckets');
        self.trace(traceHeader + 'kBuckets: ' + util.inspect(closestKBuckets, false, null));
    }

    var closestContacts = self.getClosestContacts(nodeId, closestKBuckets);

    // if none of our local kBuckets have any contacts (should only happen
    // when bootstrapping), talk to the seeds
    if (closestContacts.length == 0) {
        if (self.tracing)
            self.trace(traceHeader + 'no contacts in kBuckets, delegating to findViaSeeds()');
        return self.findViaSeeds(nodeId, callback, announce);
    }

    if (self.tracing)
        self.trace(traceHeader + 'have ' + closestContacts.length + ' closest contacts');

    // check if the closest contact is actually the node we are looking for
    if (closestContacts[0].id.toString("base64") == nodeId) {
        var contact = clone(closestContacts[0]);
        contact.id = contact.id.toString("base64");
        // hide internal implementation details
        delete contact.distance;
        var latency = self.timerEndInMilliseconds('find.ms', nodeId);
        callback(null, contact);
        self.emit('stats.timers.find.ms', latency);
        return;
    }

    // closestContacts will contain contacts with id as a Buffer, we clone
    // the contacts so that we can have id be a base64 encoded String
    var closestNodes = [];
    var nodesMap = {};
    closestContacts.forEach(function (contact) {
        var clonedContact = clone(contact);
        clonedContact.id = clonedContact.id.toString("base64");
        clonedContact.kBucket = closestKBuckets[0]; // for reference later
        closestNodes.push(clonedContact);
        nodesMap[clonedContact.id] = clonedContact;
    });

    var query = {
        nodeId: nodeId,
        nodes: closestNodes,
        nodesMap: nodesMap,
        sender: self.kBuckets[closestKBuckets[0].id].contact
    };
    self.executeQuery(query, callback);
};

/*
  * `nodeId`: _String (base64)_ Base64 encoded node id to find.
  * `callback`: _Function_ The callback to call with the result of searching for
          `nodeId`.
  * `announce`: _Object_ _(Default: undefined)_ Contact object, if specified, it
          indicates an announcement and the sender is the `announce` contact
          object.
*/
Discover.prototype.findViaSeeds = function findViaSeeds (nodeId, callback, announce) {
    var self = this;
    var traceHeader = "findViaSeeds(" + nodeId + "): ";

    // if we have no seeds, that means we don't know of any other nodes to query
    if (!self.seeds || self.seeds.length == 0) {
        if (self.tracing) {
            self.trace(traceHeader + 'No known seeds to query');
        }
        var latency = self.timerEndInMilliseconds('find.ms', nodeId);
        callback(new Error("No known seeds to query"));
        self.emit('stats.timers.find.ms', latency);
        return;
    }

    var closestNodes = [];
    var nodesMap = {};
    var nodeIdBuffer = new Buffer(nodeId, "base64");
    self.seeds.forEach(function (seed) {
        var seedIdBuffer = new Buffer(seed.id, "base64");
        var clonedSeed = clone(seed);
        clonedSeed.distance = KBucket.distance(nodeIdBuffer, seedIdBuffer);
        closestNodes.push(clonedSeed);
        nodesMap[clonedSeed.id] = clonedSeed;
    });

    closestNodes = closestNodes.sort(function (a, b) {
        return a.distance - b.distance;
    });

    // distances are now sorted, closest being first
    // TODO: probably refactor Query object to be it's own thing
    var query = {
        nodeId: nodeId,
        nodes: closestNodes,
        nodesMap: nodesMap,
        sender: announce
    };
    self.executeQuery(query, callback);
};

/*
  * `nodeId`: _String (base64)_ Base64 encoded node id to find closest contacts
          to.
  * `closestKBuckets`: _Array_ Sorted array of `KBucket`s from closest to
          furthest from `nodeId`.
  * Return: _Array_ List of closest contacts.
*/
Discover.prototype.getClosestContacts = function getClosestContacts (nodeId, closestKBuckets) {
    var self = this;

    // we pick the closest kBucket to chose nodes from as it will have the
    // most information about nodes closest to nodeId, if closest kBucket has
    // no nodes, we pick the next one, until we find a kBucket with nodes in it
    // or reach the end
    var closestContacts = [];
    var closestKBucketsIndex = 0;
    // TODO: it is possible for closestKBucket.closest({...}, 3) to return
    //       less than 3 contacts, in that case a list of less than 3 will
    //       be returned, changing while condition to use
    //       `closestContacts.length < 3` may be a bette heuristic choice
    while (closestContacts.length == 0
            && closestKBucketsIndex < closestKBuckets.length) {
        var closestKBucketId = closestKBuckets[closestKBucketsIndex].id;
        var closestKBucket = self.kBuckets[closestKBucketId].kBucket;
        // get three closest nodes
        closestContacts = closestKBucket.closest(
            {id: new Buffer(nodeId, "base64")}, 3);
        closestKBucketsIndex++;
    }

    return closestContacts;
};

/*
  * `nodeId`: _String (base64)_ Base64 encoded node id to find closest contacts
          to.
  * Return: _Array_ List of closest `KBucket`s.
*/
Discover.prototype.getClosestKBuckets = function getClosestKBuckets (nodeId) {
    var self = this;

    // TODO: change self.kBuckets data structure so that this operation is
    //       O(log n) instead of O(n), although, in proritizing this task
    //       remember the use-case of having more than one kBucket in self.kBuckets
    //       means that we are doing discover.register(contact) quite many times.
    //       It seems that for *most* use-cases, only one contact will ever be
    //       `discover.register`'ed (this registers identity of the local node)
    var closestKBuckets = [];
    var nodeIdBuffer = new Buffer(nodeId, "base64");
    Object.keys(self.kBuckets).forEach(function (kBucketKey) {
        var kBucket = self.kBuckets[kBucketKey];
        var kBucketIdBuffer = new Buffer(kBucket.id, "base64");
        closestKBuckets.push({
            id: kBucket.id,
            distance: KBucket.distance(nodeIdBuffer, kBucketIdBuffer)
        });
    });

    closestKBuckets = closestKBuckets.sort(function (a, b) {
        return a.distance - b.distance;
    });

    return closestKBuckets;
};

/*
  * `query`: _Object_ Object containing query state for this request.
    * `nodeId`: _String (base64)_ Base64 encoded node id to find.
    * `nodes`: _Array_ `contact`s to query for `nodeId` arranged from closest to
            furthest.
      * `node`:
        * `id`: _String (base64)_ Base64 encoded contact id.
    * `nodesMap`: _Object_ A map to the same `contact`s already present in
            `nodes` for O(1) access.
  * `callback`: _Function_ The callback to call with result.
*/
Discover.prototype.queryCompletionCheck = function queryCompletionCheck (query, callback) {
    var self = this;
    // console.log("QUERY COMPLETION CHECK");
    // are we done?
    if (query.index == query.nodes.length
        && query.ongoingRequests == 0 && !query.done) {
        // find out if any new nodes are closer than the closest
        // node in order to determine if we should keep going or
        // stop
        self.emit('stats.timers.find.round.ms',
            self.timerEndInMilliseconds('find.round.ms', query.nodeId));

        // console.log('sorting new nodes');
        // sort the new nodes according to distance
        var newNodes = [];
        var nodeIdBuffer = new Buffer(query.nodeId, "base64");
        query.newNodes.forEach(function (newNode) {
            var clonedNewNode = clone(newNode);
            var newNodeIdBuffer = new Buffer(newNode.id, "base64");
            clonedNewNode.distance =
                KBucket.distance(nodeIdBuffer, newNodeIdBuffer);
            // only add nodes that are closer to short circuit the
            // computation
            if (clonedNewNode.distance < query.closest.distance) {
                newNodes.push(clonedNewNode);
            }
        });

        // console.log('sorted new nodes');

        // if we don't have any closer nodes, we didn't find
        // what we are looking for
        if (newNodes.length == 0) {
            // we are done done
            self.transport.removeListener('node', query.listener);

            // console.log('listener removed');
            // console.dir(query);
            // sanity check, just in case closest node is the one
            // we are looking for and wasn't short-circuited
            // somewhere else
            if (query.closest.id == query.nodeId) {
                // console.log("returning closest node", query.closest);
                return callback(null, query.closest);
            } else {
                // console.log("returning not found error");
                var latency = self.timerEndInMilliseconds('find.ms', query.nodeId);
                callback(new Error("not found"));
                self.emit('stats.timers.find.ms', latency);
                return;
            }
        }

        // console.log("found closer nodes", newNodes);

        // found closer node, sort according to length
        newNodes = newNodes.sort(function (a, b) {
            return a.distance - b.distance;
        });

        // update query state and go another round
        query.index = 0;
        query.ongoingRequests = 0;
        query.nodes = newNodes; // these are sorted by distance (unlike query.newNodes)
        query.nodesMap = {};
        query.nodes.forEach(function (node) {
            query.nodesMap[node.id] = node;
        });
        query.closest = query.nodes[0];
        query.newNodes = [];

        return process.nextTick(function () {
            self.executeQuery(query, callback);
        });
    } // are we done?
    // console.log("FAILED QUERY COMPLETION CHECK >>> KEEP GOING");
};

/*
  * `contact`: _Object_ Contact object to register.
    * `id`: _String (base64)_ _(Default: `crypto.randomBytes(20).toString('base64'`)_
            The contact id, base 64 encoded; will be created if not present.
    * `data`: _Any_ Data to be included with the contact, it is guaranteed to be
            returned for anyone querying for this `contact` by `id`.
  * Return: _Object_ Contact that was registered with `id` and generated arbiter
      defaults if necessary.
*/
Discover.prototype.register = function register (contact) {
    var self = this;
    contact = contact || {};
    contact = clone(contact); // separate references from outside

    if (!contact.id) {
        
    var array = new Uint8Array(20);
    var randomData = window.crypto.getRandomValues(array);
 
        function Uint8ToBase64(u8Arr){
          var CHUNK_SIZE = 0x8000; //arbitrary number
          var index = 0;
          var length = u8Arr.length;
          var result = '';
          var slice;
          while (index < length) {
            slice = u8Arr.subarray(index, Math.min(index + CHUNK_SIZE, length)); 
            result += String.fromCharCode.apply(null, slice);
            index += CHUNK_SIZE;
          }
          return btoa(result);
        }

      contact.id = Uint8ToBase64(randomData);  
/*    contact.id = crypto.randomBytes(20).toString('base64'); //crypto Library replacement
*/    }

    // add transport information to the stored contact
    contact = self.transport.setTransportInfo(contact);

    contact = self.arbiterDefaults(contact);

    var traceHeader = "register(" + contact.id + "): ";

    if (!self.kBuckets[contact.id]) {
        if (self.tracing)
            self.trace(traceHeader + 'creating new bucket for ' + util.inspect(contact));
        var kBucket = new KBucket({arbiter: self.arbiter, localNodeId: contact.id});
        kBucket.on('ping', function (oldContacts, newContact) {
            // ping all the old contacts and if one does not respond, remove it
            var oldContactIdsBase64 = [];
            var reachedContactIdsBase64 = [];
            var unreachableListener = function (contact) {
                if (oldContactIdsBase64.indexOf(contact.id) > -1) {
                    self.transport.removeListener('unreachable', unreachableListener);
                    self.transport.removeListener('reached', reachedListener);
                    kBucket.remove({id: new Buffer(contact.id, "base64")});
                    kBucket.add(newContact);
                }
            };
            var reachedListener = function (contact) {
                var index = reachedContactIdsBase64.indexOf(contact.id);
                if (index > -1) {
                    reachedContactIdsBase64.splice(index, 1);
                    if (reachedContactIdsBase64.length == 0) {
                        // all contacts were reached, won't be adding new one
                        self.transport.removeListener(
                            'unreachable', unreachableListener);
                        self.transport.removeListener(
                            'reached', reachedListener);
                    }
                }
            };
            self.transport.on('reached', reachedListener);
            self.transport.on('unreachable', unreachableListener);
            var sender = self.kBuckets[contact.id].contact;
            oldContacts.forEach(function (oldContact) {
                var contact = clone(oldContact);
                contact.id = oldContact.id.toString("base64");
                oldContactIdsBase64.push(contact.id);
                reachedContactIdsBase64.push(contact.id);
                self.transport.ping(contact, sender);
            });
        });
        self.kBuckets[contact.id] = {
            contact: contact,
            id: contact.id,
            kBucket: kBucket
        };
    } else {
        if (self.tracing)
            self.trace(traceHeader + 'bucket already exists, updating contact with ' + util.inspect(contact));
        self.kBuckets[contact.id].contact = contact;
    }

    // issuing find(contact.id) against own contact.id, populates the DHT
    // with contact
    self.find(contact.id, function () {}, contact /*announce*/);

    return clone(contact); // don't leak internal implementation
};

/*
  * `type`: _String_ Timer type.
  * `key`: _String_ Timer key.
  * Return: _Number_ Milliseconds since the first time in the timer.
*/
Discover.prototype.timerEndInMilliseconds = function timerEndInMilliseconds(type, key) {
    var self = this;

    if (!self.timers[type] || !self.timers[type][key]) {
        return 0;
    }

    var diff = process.hrtime(self.timers[type][key].shift());
    if (self.timers[type][key].length == 0) {
        delete self.timers[type][key];
    }
    // diff[0] : seconds
    // diff[1] : nanoseconds
    // 1 second = 1e9 nanoseconds
    // 1 millisecond = 1e6 nanoseconds
    return Math.floor((diff[0] * 1e9 + diff[1]) / 1e6);
};

/*
  * `type`: _String_ Timer type.
  * `key`: _String_ Timer key.
*/
Discover.prototype.timerStart = function timerStart(type, key) {
    var self = this;
    self.timers[type][key] = self.timers[type][key] || [];
    self.timers[type][key].push(process.hrtime());
};

/*
  * `message`: _String_ Message to trace.
*/
Discover.prototype.trace = function(message) {
    var self = this;
    var options = self.options;

    if (options.inlineTrace)
        console.log('~trace', message);
    if (options.eventTrace)
        self.emit('~trace', message);
};

/*
  * `contact`: _Object_ Contact object to report unreachable
    * `id`: _String (base64)_ The previously registered contact id, base64
            encoded.
*/
Discover.prototype.unreachable = function unreachable (contact) {
    var self = this;
    if (self.tracing)
        self.trace('unreachable(' + util.inspect(contact) + ')');

    // even if we don't have kBuckets, remove contact from LRU cache
    self.lruCache.del(contact.id);

    // find closest KBucket to remove unreachable contact from
    var closestKBuckets = self.getClosestKBuckets(contact.id);
    if (closestKBuckets.length == 0) {
        if (self.tracing)
            self.trace('no kBuckets for unreachable(contact) ' + util.inspect(contact));
        return;
    }
    var closestKBucketId = closestKBuckets[0].id;
    var closestKBucket = self.kBuckets[closestKBucketId].kBucket;
    if (!closestKBucket) {
        if (self.tracing)
            self.trace('no closest kBucket for unreachable(contact) ' + util.inspect(contact));
        return;
    }
    var clonedContact = clone(contact);
    if (self.tracing)
        self.trace('removing ' + util.inspect(contact) + ' from kBucket ' + closestKBucketId);
    clonedContact.id = new Buffer(contact.id, "base64");
    closestKBucket.remove(clonedContact);
};

/*
  * `contact`: _Object_ Contact object to register
    * `id`: _String (base64)_ The previously registered contact id, base 64
            encoded.
*/
Discover.prototype.unregister = function unregister (contact) {
    var self = this;
    var kBucket = self.kBuckets[contact.id];
    if (kBucket) {
        if (kBucket.contact === self.arbiter(kBucket.contact, contact)
            && kBucket.contact !== contact) {
            // by returning the stored contact, arbiter determined that
            // unregister should fail as an attempt to unregister using
            // old data has been made
            return;
        }
        delete self.kBuckets[contact.id];
    }

    // current implemenation deletes all that "closest" contact information
    // that was gathered in the unregistering kBucket

    // TODO: elaborate the implementation to distribute known nodes in this
    //       kBucket to ones that aren't being deleted
};

return module.exports;

};

//</script>